Алгоритмы в данной программе:

Алгоритм поиска в ширину (Breadth-first Search, BFS) — это один из базовых алгоритмов обхода графа. Он используется для поиска кратчайшего пути в невзвешенном графе, а также для проверки связности графа. Вот как он работает:

Принцип работы алгоритма BFS:
1.Инициализация: Алгоритм начинает свою работу с узла, который определен как начальная точка. Все узлы графа инициализируются как не посещенные.
2.Очередь: BFS использует структуру данных очередь для хранения узлов, которые необходимо обработать. В начале работы алгоритма в очередь помещается начальный узел.
3.Обработка узлов:
Извлекается узел из начала очереди.
Проверяется, был ли этот узел посещен. Если да, то алгоритм переходит к следующему узлу в очереди.
Если узел не был посещен, он помечается как посещенный.
Для извлеченного узла рассматриваются все соседние узлы. Все не посещенные соседи добавляются в конец очереди.
4.Продолжение до опустошения очереди: Эти шаги повторяются, пока очередь не станет пустой.
5.Конец работы: Как только очередь опустеет, алгоритм завершает свою работу. Если цель поиска — найти путь до конкретного узла, алгоритм может завершиться раньше, как только целевой узел будет достигнут.

Особенности BFS:
Поиск в ширину гарантирует нахождение кратчайшего пути в невзвешенном графе, так как он исследует все узлы на одном уровне расстояния от начального узла, прежде чем перейти к узлам следующего уровня.
Память: BFS требует значительного объема памяти, так как в худшем случае нужно хранить все узлы одного уровня.
Применимость: Алгоритм часто используется в задачах, связанных с поиском в ширину, таких как поиск кратчайшего пути в невзвешенных графах, определение всех уровней в ширину от данного узла, проверка связности графа и другие.

DFS

Алгоритм поиска в глубину (Depth-first Search, DFS) — это ещё один фундаментальный метод обхода или поиска в графе. Он используется для исследования графа или дерева от начальной точки до самого дальнего узла по каждому пути перед тем, как откатиться назад и продолжить поиск по следующему пути. Вот как работает этот алгоритм:

Принцип работы DFS:
1.Инициализация: Алгоритм начинает свою работу с узла, который определен как начальная точка. Все узлы графа инициализируются как не посещенные.
2.Стек или рекурсия: DFS может использовать структуру данных стек или рекурсивные вызовы (которые используют системный стек вызовов) для хранения узлов, которые нужно обработать. В начале работы в стек помещается начальный узел.
3.Обработка узлов:
Узел извлекается из стека.
Если узел не был посещен, он помечается как посещенный.
Затем рассматриваются все соседние узлы узла. Не посещенные соседи добавляются в стек. DFS продолжает углубляться, добавляя узлы в стек и переходя к ближайшему необработанному соседу.
4.Откат (Backtracking): Как только алгоритм достигает узла, из которого не осталось переходов в не посещенные узлы, он начинает откат: алгоритм возвращается к предыдущим узлам, чтобы исследовать другие пути. Этот процесс продолжается, пока не будут исследованы все возможные пути от начального узла или пока не будет найден узел-цель.
5.Конец работы: DFS завершает работу, когда стек опустеет или когда найден узел-цель.

Особенности DFS:
1.Исследование: DFS исследует граф до самых глубин, что может быть полезно для задач, требующих полного изучения всех вариантов (например, проверка связности компонент, нахождение компонент сильной связности).
2.Память: В худшем случае DFS использует память в размере максимальной глубины рекурсии, что может быть значительно меньше памяти, требуемой для BFS в широких графах.
3.Не гарантирует нахождение кратчайшего пути: В отличие от BFS, DFS не гарантирует нахождение кратчайшего пути в графе.
DFS используется во многих алгоритмах, включая алгоритмы для топологической сортировки, поиска компонент сильной связности, исследования лабиринтов, генерации мазов и многих других задач, где требуется исследование всех возможных путей или конфигураций.

Алгоритм Uniform Cost Search (UCS), также известный как алгоритм Дейкстры для поиска кратчайшего пути, — это метод поиска в графе, который находит путь с наименьшей стоимостью от начальной вершины до целевой вершины. Он использует принцип оптимальности, где на каждом шаге выбирается путь с наименьшей суммарной стоимостью от начала.

### Принцип работы Uniform Cost Search:

1. **Инициализация**: Алгоритм начинается с начального узла, стоимость пути до которого изначально равна нулю. Все остальные узлы инициализируются с бесконечной стоимостью пути.

2. **Приоритетная очередь**: UCS использует приоритетную очередь (чаще всего реализуемую через минимальную кучу), где узлы сортируются по стоимости пути от начального узла. В начале работы в очередь помещается только начальный узел.

3. **Обработка узлов**:

    - Из очереди извлекается узел с наименьшей суммарной стоимостью пути.
    - Для каждого соседнего узла рассчитывается новая суммарная стоимость пути, путём добавления стоимости перехода от текущего узла к соседу.
    - Если рассчитанная стоимость пути до соседа оказывается меньше текущей известной стоимости до этого соседа, то обновляется стоимость пути до соседа, и сосед добавляется в приоритетную очередь с новой стоимостью пути.

4. **Завершение работы**: Процесс продолжается до тех пор, пока приоритетная очередь не опустеет или пока не будет найден целевой узел. Алгоритм завершается, когда целевой узел извлекается из очереди, поскольку это гарантирует, что найден путь с наименьшей стоимостью.

### Особенности UCS:

-   **Оптимальность**: UCS гарантирует нахождение пути с наименьшей стоимостью благодаря систематическому расширению наименее дорогих путей.
-   **Использование памяти**: Как и в случае с BFS, UCS может требовать значительного объема памяти для хранения всех узлов в приоритетной очереди.
-   **Применение**: UCS идеально подходит для графов с положительными весами ребер, где требуется гарантированное нахождение наименьшей стоимости пути.

Uniform Cost Search широко используется в областях, где необходим точный поиск оптимального пути, таких как сетевое планирование, планирование маршрутов, искусственный интеллект для игр и многие другие задачи.

GBFS

Алгоритм жадного поиска по первому наилучшему соответствию (Greedy Best First Search, GBFS) — это метод поиска пути в графе, который стремится минимизировать расстояние до целевого узла, используя эвристическую оценку. Этот алгоритм выбирает для расширения тот узел, который на данный момент кажется наиболее приближенным к цели, основываясь на заданной эвристической функции, оценивающей "стоимость" пути от узла до цели.

Принцип работы Greedy Best First Search:
1.Инициализация: Алгоритм начинается с начального узла. Для каждого узла определяется его эвристическая стоимость расстояния до цели. Начальный узел помещается в приоритетную очередь на основе этой эвристической стоимости.
Приоритетная очередь: GBFS использует приоритетную очередь для управления порядком обработки узлов. Узлы с наименьшей эвристической оценкой расстояния до цели обрабатываются в первую очередь.
2.Обработка узлов:
Из очереди извлекается узел с наименьшей эвристической стоимостью.
Если этот узел является целевым, поиск завершается успешно.
В противном случае, для каждого соседа текущего узла вычисляется эвристическая стоимость и, если этот сосед еще не был посещен или найден более короткий путь, он добавляется в приоритетную очередь.
Завершение работы: Процесс продолжается, пока приоритетная очередь не опустеет или пока не будет найден целевой узел.
3.Особенности GBFS:
4.Жадность: GBFS является жадным алгоритмом, поскольку всегда выбирает для расширения узел, который на данный момент кажется наиболее близким к цели, не учитывая стоимость пути, пройденного до этого узла.
Не гарантирует оптимальное решение: В отличие от A\* или UCS, GBFS не гарантирует нахождение кратчайшего или наименее затратного пути, так как он не учитывает общую стоимость пути.

A*
Алгоритм A-star (A*) — это мощный и эффективный алгоритм поиска пути на графах, который использует оценки для нахождения наиболее перспективного пути к целевой вершине. Это усовершенствование алгоритмов, таких как жадный поиск по первому наилучшему совпадению и поиск с наименьшей стоимостью (Uniform Cost Search), сочетающее лучшие их качества.

### Принцип работы A\*:

1. **Инициализация**: A\* начинает свою работу с начальной вершины. Каждая вершина оценивается по функции \( f(n) = g(n) + h(n) \), где:

    - \( g(n) \) — стоимость пути от начальной вершины до вершины \( n \),
    - \( h(n) \) — эвристическая оценка стоимости пути от \( n \) до целевой вершины. Эта оценка должна быть адмиссимой, т.е. не переоценивать действительную стоимость достижения цели.

2. **Приоритетная очередь**: Все вершины, которые нужно обработать, хранятся в приоритетной очереди (как правило, реализуемой через мин-кучу), где приоритет определяется значением функции \( f(n) \). Начальная вершина добавляется в очередь с \( f(n) \) равным \( h(n) \), поскольку \( g(n) \) для неё равно 0.

3. **Обработка вершин**:

    - Из очереди извлекается вершина с наименьшим значением \( f(n) \).
    - Для каждой смежной вершины \( m \) рассчитывается стоимость пути \( g(m) \), которая равна \( g(n) \) плюс стоимость перехода от \( n \) к \( m \).
    - Если новая стоимость пути \( g(m) \) меньше ранее известной стоимости, то обновляется значение \( g(m) \), и вершина \( m \) добавляется в приоритетную очередь с новым значением \( f(m) = g(m) + h(m) \).

4. **Критерий остановки**: Алгоритм продолжает свою работу до тех пор, пока приоритетная очередь не опустеет или пока не будет найдена целевая вершина. Обработка завершается, когда целевая вершина извлекается из очереди, что означает, что найден путь с наименьшей оценочной стоимостью до цели.

### Особенности A\*:

-   **Эффективность**: A\* эффективен, если используется хорошая эвристическая функция. Хорошая эвристика значительно сокращает количество обрабатываемых вершин.
-   **Адмиссимость и состязательность**: Если эвристика адмиссима и состязательная (т.е., не переоценивает стоимость достижения цели и стремится к минимуму), A\* гарантирует нахождение оптимального пути.
-   **Применимость**: A\* широко используется в различных приложениях, от игр и робототехники до сетевых маршрутизаций и планирования задач.

A\* является одним из

лучших выборов для задач планирования и навигации в сложных средах благодаря своей гибкости и эффективности.

Алгоритм двунаправленного поиска (Bidirectional Search) — это метод поиска в графах, который эффективно находит кратчайший путь между начальной и конечной точками. Этот алгоритм запускает два одновременных поиска: один от начальной вершины к конечной, а другой — от конечной к начальной, и останавливается, когда оба поиска встречаются в середине пути.

### Принцип работы двунаправленного поиска:

1. **Инициализация**: Алгоритм начинает два поиска одновременно — один из начальной вершины (forward search) и один из конечной вершины (backward search). Каждый поиск может использовать любой метод обхода графа, например, поиск в ширину (BFS) или поиск в глубину (DFS).

2. **Одновременный поиск**: Оба поиска продвигаются поочередно, шаг за шагом. Например, можно выполнить один уровень поиска в ширину для forward search, затем один уровень для backward search, и так далее.

3. **Встреча поисков**: Алгоритм продолжается до тех пор, пока поиски не встретятся — т.е., до тех пор, пока не будет найден общий узел, который был исследован обоими поисками.

4. **Объединение путей**: После встречи двух поисков пути, найденные каждым из поисков, объединяются для формирования полного пути от начальной до конечной вершины. Это делается путем соединения пути из начальной вершины к встречной точке и пути из встречной точки к конечной вершине.

### Особенности двунаправленного поиска:

-   **Эффективность**: Двунаправленный поиск часто более эффективен, чем однонаправленный, поскольку каждый из поисков обычно обходит меньшее число узлов. Это сокращает общее количество обрабатываемых узлов вдвое при исследовании каждым поиском только до середины пути.
-   **Сложность реализации**: Алгоритм требует более сложной реализации, особенно в части определения точки встречи и объединения путей.
-   **Требование к памяти**: Для каждого поиска нужно хранить набор посещенных узлов, что удваивает потребление памяти по сравнению с однонаправленным поиском.
-   **Применение**: Часто используется в задачах планирования маршрутов и навигации, где известны и начальная, и конечная точки.

Двунаправленный поиска является мощным инструментом в теории алгоритмов и на практике, обеспечивая ускорение поиска пути в ситуациях, когда обе точки маршрута заранее определены.
